/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _index = __webpack_require__(2);

	var _index2 = _interopRequireDefault(_index);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _xvdomEl = _index2.default.el;
	var _xvdomSpec = {
	  c: function c() {
	    var _n = _xvdomEl('b');

	    _n.appendChild(document.createTextNode(('hello') || ''));

	    return _n;
	  },
	  u: function u() {},
	  r: _index2.default.DEADPOOL
	};


	var TAG_TO_REF = _index.REF_TO_TAG.reduce(function (acc, tag, i) {
	  return acc[tag] = i, acc;
	}, {});

	var flatten = function flatten(arrayOfArrays) {
	  return arrayOfArrays.reduce(function (acc, arr) {
	    return acc.concat(arr);
	  }, []);
	};

	var _elChildren = function _elChildren() {
	  var children = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

	  var result = children.length ? [6].concat(flatten(children), [7]) : children;
	  return result;
	};

	var _static = function _static(valueId) {
	  return [5, valueId];
	};
	var dynamic = function dynamic(valueId) {
	  return [4, valueId];
	};

	var props = function props(_ref) {
	  var _ref$dynamics = _ref.dynamics;
	  var dynamics = _ref$dynamics === undefined ? [] : _ref$dynamics;
	  var _ref$statics = _ref.statics;
	  var statics = _ref$statics === undefined ? [] : _ref$statics;
	  return [statics.length, dynamics.length + statics.length].concat(dynamics, statics);
	};

	var el = function el(tag) {
	  for (var _len = arguments.length, children = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    children[_key - 1] = arguments[_key];
	  }

	  return [0, TAG_TO_REF[tag]].concat(_elChildren(children));
	};

	var componentWithProps = function componentWithProps(comp, _props) {
	  return [3, comp].concat(props(_props));
	};

	// Generated by instrumenting xvdom to count every dynamic rendered for a
	// non-trivial app (currently ticker).
	var COUNTS = {
	  boolean: 1,
	  null: 10,
	  string: 49,
	  number: 0,
	  instance: 36,
	  array: 5
	};

	var DYNAMIC_FACTORIES = {
	  string: function string(i) {
	    return 'hello ' + String.fromCharCode(65 + i % 26);
	  },
	  instance: function instance(i) {
	    return {
	      $s: _xvdomSpec
	    };
	  },
	  null: function _null(i) {
	    return null;
	  },
	  array: function array(i) {
	    return [];
	  },
	  boolean: function boolean(i) {
	    return !(i % 2);
	  },
	  number: function number(i) {
	    return i;
	  }
	};

	var createValues = function createValues(counts, numValues, reverse) {
	  var keys = (reverse ? function (a) {
	    return a.reverse();
	  } : function (a) {
	    return a;
	  })(Object.keys(counts));
	  var sum = keys.reduce(function (sum, key) {
	    return sum + counts[key];
	  }, 0);
	  var values = [];
	  var i = 0;

	  keys.forEach(function (key) {
	    var numOfDynamics = 100 * (counts[key] / sum) | 0;
	    while (numOfDynamics--) {
	      values[i++] = DYNAMIC_FACTORIES[key](i);
	    }
	  });

	  return values;
	};

	// const BYTECODE_CompPart = window.BYTECODE_CompPart = el('div',
	//   el('span', dynamic(0)),
	//   el('span', dynamic(1)),
	//   el('span', dynamic(2)),
	//   el('span', dynamic(3)),
	//   el('span', dynamic(4))
	// );
	var BYTECODE_CompPart = {
	  b: [0, 2, 6, 0, 4, 6, 4, 0, 7, 0, 4, 6, 4, 1, 7, 0, 4, 6, 4, 2, 7, 0, 4, 6, 4, 3, 7, 0, 4, 6, 4, 4, 7, 7],
	  s: []
	};

	var CompPart = function CompPart(_ref2) {
	  var start = _ref2.start;
	  var values = _ref2.values;

	  return {
	    t: BYTECODE_CompPart,
	    d: [values[0 + start], values[1 + start], values[2 + start], values[3 + start], values[4 + start]]
	  };
	};

	var BYTECODE_CompPartPrefix = {
	  b: [0, 2, 6, 0, 4, 6, 0, 4, 6, 5, 0, 7, 4, 0, 7, 0, 4, 6, 0, 4, 6, 5, 0, 7, 4, 1, 7, 0, 4, 6, 0, 4, 6, 5, 0, 7, 4, 2, 7, 0, 4, 6, 0, 4, 6, 5, 0, 7, 4, 3, 7, 0, 4, 6, 0, 4, 6, 5, 0, 7, 4, 4, 7, 7],
	  s: ['prefix']
	};
	// const BYTECODE_CompPartPrefix = window.BYTECODE_CompPartPrefix =  el('div',
	//   el('span',
	//     el('span', _static(0)),
	//     dynamic(0)
	//   ),
	//   el('span',
	//     el('span', _static(0)),
	//     dynamic(1)
	//   ),
	//   el('span',
	//     el('span', _static(0)),
	//     dynamic(2)
	//   ),
	//   el('span',
	//     el('span', _static(0)),
	//     dynamic(3)
	//   ),
	//   el('span',
	//     el('span', _static(0)),
	//     dynamic(4
	//   ))
	// );

	var CompPartPrefix = function CompPartPrefix(_ref3) {
	  var start = _ref3.start;
	  var values = _ref3.values;
	  return {
	    t: BYTECODE_CompPartPrefix,
	    d: [values[0 + start], values[1 + start], values[2 + start], values[3 + start], values[4 + start]]
	  };
	};

	// const BYTECODE_Comp = window.BYTECODE_Comp = el('div',
	//   componentWithProps(0, {dynamics: [0], statics: [2]}),
	//   componentWithProps(0, {dynamics: [0], statics: [4]}),
	//   componentWithProps(0, {dynamics: [0], statics: [6]}),
	//   componentWithProps(0, {dynamics: [0], statics: [8]}),
	//   componentWithProps(0, {dynamics: [0], statics: [10]}),
	//   componentWithProps(0, {dynamics: [0], statics: [12]}),
	//   componentWithProps(0, {dynamics: [0], statics: [14]}),
	//   componentWithProps(0, {dynamics: [0], statics: [16]}),
	//   componentWithProps(0, {dynamics: [0], statics: [18]}),
	//   componentWithProps(0, {dynamics: [0], statics: [20]}),
	//
	//   componentWithProps(1, {dynamics: [0], statics: [22]}),
	//   componentWithProps(1, {dynamics: [0], statics: [24]}),
	//   componentWithProps(1, {dynamics: [0], statics: [26]}),
	//   componentWithProps(1, {dynamics: [0], statics: [28]}),
	//   componentWithProps(1, {dynamics: [0], statics: [30]}),
	//   componentWithProps(1, {dynamics: [0], statics: [32]}),
	//   componentWithProps(1, {dynamics: [0], statics: [34]}),
	//   componentWithProps(1, {dynamics: [0], statics: [36]}),
	//   componentWithProps(1, {dynamics: [0], statics: [38]}),
	//   componentWithProps(1, {dynamics: [0], statics: [40]})
	// );
	var BYTECODE_Comp = {
	  b: [0, 2, 6, 3, 0, 1, 2, 0, 2, 3, 0, 1, 2, 0, 4, 3, 0, 1, 2, 0, 6, 3, 0, 1, 2, 0, 8, 3, 0, 1, 2, 0, 10, 3, 0, 1, 2, 0, 12, 3, 0, 1, 2, 0, 14, 3, 0, 1, 2, 0, 16, 3, 0, 1, 2, 0, 18, 3, 0, 1, 2, 0, 20, 3, 1, 1, 2, 0, 22, 3, 1, 1, 2, 0, 24, 3, 1, 1, 2, 0, 26, 3, 1, 1, 2, 0, 28, 3, 1, 1, 2, 0, 30, 3, 1, 1, 2, 0, 32, 3, 1, 1, 2, 0, 34, 3, 1, 1, 2, 0, 36, 3, 1, 1, 2, 0, 38, 3, 1, 1, 2, 0, 40, 7],
	  s: [CompPart, CompPartPrefix, 'start', 0, 'start', 5, 'start', 10, 'start', 15, 'start', 20, 'start', 25, 'start', 30, 'start', 35, 'start', 40, 'start', 45, 'start', 50, 'start', 55, 'start', 60, 'start', 65, 'start', 70, 'start', 75, 'start', 80, 'start', 85, 'start', 90, 'start', 92]
	};

	var Comp = function Comp(_ref4) {
	  var values = _ref4.values;
	  return {
	    t: BYTECODE_Comp,
	    d: ['values', values]
	  };
	};

	// const BYTECODE_MAIN = window.BYTECODE_MAIN = componentWithProps(0, {dynamics: [0]});
	var BYTECODE_MAIN = {
	  b: [3, 0, 0, 1, 0],
	  s: [Comp]
	};

	// const renderInstance = (values)=> <Comp values={values} />;
	var renderInstance = function renderInstance(values) {
	  return {
	    t: BYTECODE_MAIN,
	    d: ['values', values]
	  };
	};

	// const render = ()=>
	//   xvdom.render(renderInstance(createValues(COUNTS, 100)));
	var render = function render() {
	  return _index2.default.xrender(renderInstance(createValues(COUNTS, 100)));
	};

	// const rerender = (node)=>
	//   xvdom.rerender(node, renderInstance(createValues(COUNTS, 100, true)));

	var benchmark = function benchmark() {
	  var i = 0;
	  // let node;
	  while (i++ < 1000) {
	    /*node = */render();
	    // rerender(node);
	  }
	};

	var test = function test() {
	  var EXPECTED_TEXT_CONTENT = 'helloKhelloLhelloMhelloNhelloOhelloPhelloQhelloRhelloShelloThelloUhelloVhelloWhelloXhelloYhelloZhelloAhelloBhelloChelloDhelloEhelloFhelloGhelloHhelloIhelloJhelloKhelloLhelloMhelloNhelloOhelloPhelloQhelloRhelloShelloThelloUhelloVhelloWhelloXhelloYprefixhelloZprefixhelloAprefixhelloBprefixhelloCprefixhelloDprefixhelloEprefixhelloFprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixhelloprefixprefixprefixprefixprefixprefixprefixprefix';
	  // const EXPECTED_TEXT_CONTENT_RERENDER = 'hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohelloOhelloPhelloQhelloRhelloShelloThelloUhelloVhelloWhelloXhelloYprefixhelloZprefixhelloAprefixhelloBprefixhelloCprefixhelloDprefixhelloEprefixhelloFprefixhelloGprefixhelloHprefixhelloIprefixhelloJprefixhelloKprefixhelloLprefixhelloMprefixhelloNprefixhelloOprefixhelloPprefixhelloQprefixhelloRprefixhelloSprefixhelloTprefixhelloUprefixhelloVprefixhelloWprefixhelloXprefixhelloYprefixhelloZprefixhelloAprefixhelloBprefixhelloCprefixhelloDprefixhelloEprefixhelloFprefixhelloGprefixhelloHprefixhelloIprefixhelloJprefixprefixprefixprefixprefixprefixprefixprefixprefixprefixprefixprefixprefix';
	  var node = render();

	  var textContent = node.textContent.replace(/\s+/g, '');
	  var pass = textContent === EXPECTED_TEXT_CONTENT;
	  var message = '';
	  message += pass ? 'SUCCESS' : 'FAIL: expected textContent to be...\n"' + EXPECTED_TEXT_CONTENT + '"\nbut got...\n"' + textContent + '"';

	  // rerender(node);
	  //
	  // textContent = node.textContent.replace(/\s+/g, '');
	  // pass = textContent === EXPECTED_TEXT_CONTENT_RERENDER;
	  // message += (
	  //   pass
	  //     ? 'RERENDER SUCCESS'
	  //     : `RERENDER FAIL: expected textContent to be...\n"${EXPECTED_TEXT_CONTENT_RERENDER}"\nbut got...\n"${textContent}"`
	  // );

	  document.write(message);
	};

	var runBenchmark = function runBenchmark() {
	  var end;
	  var start = window.performance.now();
	  benchmark();
	  end = window.performance.now();
	  document.write((end - start).toFixed(3) + 'ms');
	};

	if (window.location.search === '?test/') test();else runBenchmark();

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	/*

	Instance properties:

	$n = DOM node
	$s - spec (see below)
	$x - Pool linked list next pointer

	Spec properties:

	c - create (or render)
	u - update (or update)
	r - keyed map of unmounted instanced that can be recycled

	*/

	var REF_TO_TAG = exports.REF_TO_TAG = ['a', 'b', 'div', 'i', 'span'];

	var START_NODE = {
	  root: null,
	  appendChild: function appendChild(node) {
	    return this.root = node;
	  }
	};

	// Creates an empty object with no built in properties (ie. `constructor`).
	function Hash() {}
	Hash.prototype = Object.create(null);

	var EMPTY_PROPS = new Hash();
	var DEADPOOL = exports.DEADPOOL = {
	  push: function push() {},
	  pop: function pop() {}
	};

	// TODO: Benchmark whether this is slower than Function/Prototype
	function Pool() {
	  this.map = new Hash();
	};

	Pool.prototype.push = function (instance) {
	  var key = instance.key;
	  var map = this.map;

	  instance.$x = map[key];
	  map[key] = instance;
	};

	Pool.prototype.pop = function (key) {
	  var head = this.map[key];
	  if (!head) return;
	  this.map[key] = head.$x;
	  return head;
	};

	var recycle = function recycle(instance) {
	  instance.$s.r.push(instance);
	};
	var createTextNode = function createTextNode(value) {
	  return document.createTextNode(value);
	};
	var createEmptyTextNode = function createEmptyTextNode() {
	  return createTextNode('');
	};

	var replaceNode = function replaceNode(oldNode, newNode) {
	  var parentNode = oldNode.parentNode;
	  if (parentNode) parentNode.replaceChild(newNode, oldNode);
	};

	var insertBefore = function insertBefore(parentNode, node, beforeNode) {
	  return beforeNode ? parentNode.insertBefore(node, beforeNode) : parentNode.appendChild(node);
	};

	var unmountInstance = function unmountInstance(inst, parentNode) {
	  recycle(inst);
	  parentNode.removeChild(inst.$n);
	};

	var removeArrayNodes = function removeArrayNodes(array, parentNode) {
	  var length = array.length;
	  var i = 0;

	  while (i < length) {
	    unmountInstance(array[i++], parentNode);
	  }
	};

	var removeArrayNodesOnlyChild = function removeArrayNodesOnlyChild(array, parentNode) {
	  var length = array.length;
	  var i = 0;

	  while (i < length) {
	    recycle(array[i++]);
	  }
	  parentNode.textContent = '';
	};

	var internalRerenderInstance = function internalRerenderInstance(inst, prevInst) {
	  return prevInst.$s === inst.$s && (inst.$s.u(inst, prevInst), true);
	};

	var renderArrayToParentBefore = function renderArrayToParentBefore(parentNode, array, length, markerNode) {
	  var i = 0;

	  while (i < length) {
	    insertBefore(parentNode, (array[i] = internalRender(array[i])).$n, markerNode);
	    ++i;
	  }
	};

	var renderArrayToParent = function renderArrayToParent(parentNode, array, length) {
	  var i = 0;

	  while (i < length) {
	    parentNode.appendChild((array[i] = internalRender(array[i])).$n);
	    ++i;
	  }
	};

	var rerenderArray_reconcileWithMap = function rerenderArray_reconcileWithMap(parentNode, array, oldArray, startIndex, endIndex, oldStartItem, oldStartIndex, oldEndItem, oldEndIndex) {
	  var oldListNodeKeyMap = new Map();
	  var insertBeforeNode = oldEndItem.$n;
	  var item = void 0,
	      key = void 0,
	      startItem = void 0;

	  while (oldStartIndex <= oldEndIndex) {
	    item = oldArray[oldStartIndex++];
	    oldListNodeKeyMap.set(item.key, item);
	  }

	  while (startIndex <= endIndex) {
	    startItem = array[startIndex];
	    key = startItem.key;
	    item = oldListNodeKeyMap.get(key);

	    if (item) {
	      if (item === oldEndItem) insertBeforeNode = insertBeforeNode.nextSibling;
	      oldListNodeKeyMap.delete(key);
	      startItem = internalRerender(item, startItem);
	    } else {
	      startItem = internalRender(startItem);
	    }
	    array[startIndex] = startItem;
	    insertBefore(parentNode, startItem.$n, insertBeforeNode);
	    ++startIndex;
	  }

	  oldListNodeKeyMap.forEach(function (value) {
	    unmountInstance(value, parentNode);
	  });
	};

	var rerenderArray_afterReconcile = function rerenderArray_afterReconcile(parentNode, array, oldArray, startIndex, startItem, endIndex, endItem, oldStartIndex, oldStartItem, oldEndIndex, oldEndItem, insertBeforeNode) {
	  if (oldStartIndex > oldEndIndex) {
	    while (startIndex <= endIndex) {
	      startItem = array[startIndex];
	      insertBefore(parentNode, (array[startIndex] = internalRender(startItem)).$n, insertBeforeNode);
	      ++startIndex;
	    }
	  } else if (startIndex > endIndex) {
	    while (oldStartIndex <= oldEndIndex) {
	      unmountInstance(oldArray[oldStartIndex++], parentNode);
	    }
	  } else {
	    rerenderArray_reconcileWithMap(parentNode, array, oldArray, startIndex, endIndex, oldStartItem, oldStartIndex, oldEndItem, oldEndIndex);
	  }
	};

	var rerenderArray_reconcile = function rerenderArray_reconcile(parentNode, array, endIndex, oldArray, oldEndIndex, markerNode) {
	  var oldStartIndex = 0;
	  var startIndex = 0;
	  var successful = true;
	  var startItem = array[0];
	  var oldStartItem = oldArray[0];
	  var insertBeforeNode = markerNode;
	  var oldEndItem = void 0,
	      endItem = void 0,
	      node = void 0;
	  endIndex--;
	  oldEndIndex--;

	  outer: while (successful && oldStartIndex <= oldEndIndex && startIndex <= endIndex) {
	    successful = false;

	    while (oldStartItem.key === startItem.key) {
	      array[startIndex] = internalRerender(oldStartItem, startItem);

	      oldStartIndex++;startIndex++;
	      if (oldStartIndex > oldEndIndex || startIndex > endIndex) {
	        break outer;
	      } else {
	        oldStartItem = oldArray[oldStartIndex];
	        startItem = array[startIndex];
	        successful = true;
	      }
	    }

	    oldEndItem = oldArray[oldEndIndex];
	    endItem = array[endIndex];

	    while (oldEndItem.key === endItem.key) {
	      insertBeforeNode = (array[endIndex] = internalRerender(oldEndItem, endItem)).$n;

	      oldEndIndex--;endIndex--;
	      if (oldStartIndex > oldEndIndex || startIndex > endIndex) {
	        break outer;
	      } else {
	        oldEndItem = oldArray[oldEndIndex];
	        endItem = array[endIndex];
	        successful = true;
	      }
	    }

	    while (oldStartItem.key === endItem.key) {
	      node = (array[endIndex] = internalRerender(oldStartItem, endItem)).$n;

	      if (oldEndItem.key !== endItem.key) {
	        insertBeforeNode = insertBefore(parentNode, node, insertBeforeNode);
	      }
	      oldStartIndex++;endIndex--;
	      if (oldStartIndex > oldEndIndex || startIndex > endIndex) {
	        break outer;
	      } else {
	        oldStartItem = oldArray[oldStartIndex];
	        endItem = array[endIndex];
	        successful = true;
	      }
	    }

	    while (oldEndItem.key === startItem.key) {
	      insertBefore(parentNode, (array[startIndex] = internalRerender(oldEndItem, startItem)).$n, oldStartItem.$n);

	      oldEndIndex--;startIndex++;
	      if (oldStartIndex > oldEndIndex || startIndex > endIndex) {
	        break outer;
	      } else {
	        oldEndItem = oldArray[oldEndIndex];
	        startItem = array[startIndex];
	        successful = true;
	      }
	    }
	  }

	  if (startIndex <= endIndex || oldStartIndex <= oldEndIndex) {
	    rerenderArray_afterReconcile(parentNode, array, oldArray, startIndex, startItem, endIndex, endItem, oldStartIndex, oldStartItem, oldEndIndex, oldEndItem, insertBeforeNode);
	  }
	};

	var rerenderArray = function rerenderArray(markerNode, array, oldArray) {
	  var parentNode = markerNode.parentNode;
	  var length = array.length;
	  var oldLength = oldArray.length;
	  if (!length) {
	    removeArrayNodes(oldArray, parentNode);
	  } else if (!oldLength) {
	    renderArrayToParentBefore(parentNode, array, length, markerNode);
	  } else {
	    rerenderArray_reconcile(parentNode, array, length, oldArray, oldLength, markerNode);
	  }
	};

	var rerenderArrayOnlyChild = function rerenderArrayOnlyChild(parentNode, array, oldArray) {
	  var length = array.length;
	  var oldLength = oldArray.length;
	  if (!length) {
	    removeArrayNodesOnlyChild(oldArray, parentNode);
	  } else if (!oldLength) {
	    renderArrayToParent(parentNode, array, length);
	  } else {
	    rerenderArray_reconcile(parentNode, array, length, oldArray, oldLength, null);
	  }
	};

	var rerenderText = function rerenderText(isOnlyChild, value, contextNode) {
	  switch (value && value.constructor) {
	    case String:
	    case Number:
	    case 0:
	      contextNode.nodeValue = value;
	      return contextNode;

	    case Object:
	    case Array:
	      return rerenderDynamic(isOnlyChild, value, contextNode);

	    default:
	      contextNode.nodeValue = '';
	      return contextNode;
	  }
	};

	var rerenderDynamic = function rerenderDynamic(isOnlyChild, value, contextNode) {
	  var node = createDynamic(isOnlyChild, contextNode.parentNode, value);
	  replaceNode(contextNode, node);
	  return node;
	};

	var rerenderInstance = function rerenderInstance(isOnlyChild, value, prevValue, node) {
	  var prevRenderedInstance = void 0;
	  if (value && internalRerenderInstance(value, prevRenderedInstance = prevValue.$r || prevValue)) {
	    value.$r = prevRenderedInstance;
	    return node;
	  }

	  return rerenderDynamic(isOnlyChild, value, node);
	};

	// TODO: Figure out whether we're using all these arguments
	var rerenderComponent = function rerenderComponent(component, props, componentInstance, instance, componentInstanceProp) {
	  var newCompInstance = component(props || EMPTY_PROPS);
	  if (!internalRerenderInstance(newCompInstance, componentInstance)) {
	    replaceNode(componentInstance.$n, (instance[componentInstanceProp] = internalRender(newCompInstance)).$n);
	  }
	};

	var rerenderArrayMaybe = function rerenderArrayMaybe(isOnlyChild, array, oldArray, markerNode) {
	  if (array instanceof Array) {
	    if (isOnlyChild) {
	      rerenderArrayOnlyChild(markerNode, array, oldArray);
	    } else {
	      rerenderArray(markerNode, array, oldArray);
	    }
	  } else {
	    if (isOnlyChild) {
	      removeArrayNodesOnlyChild(oldArray, markerNode);
	      return markerNode.appendChild(createDynamic(true, markerNode, array));
	    } else {
	      removeArrayNodes(oldArray, markerNode.parentNode);
	      return rerenderDynamic(false, array, markerNode);
	    }
	  }
	};

	var rerenderStatefulComponent = function rerenderStatefulComponent(component, newProps, api) {
	  var _onProps = api._onProps;
	  var props = api.props;

	  api.props = newProps;

	  if (_onProps) componentSend(component, api, _onProps, props);else componentRerender(component, api);
	};

	var updateDynamic = function updateDynamic(isOnlyChild, oldValue, value, contextNode) {
	  switch (oldValue && oldValue.constructor) {
	    case Array:
	      return rerenderArrayMaybe(isOnlyChild, value, oldValue, contextNode.xvdomContext) || contextNode;

	    case Object:
	      return rerenderInstance(isOnlyChild, value, oldValue, contextNode);

	    default:
	      return rerenderText(isOnlyChild, value, contextNode);
	  }
	};

	var createArray = function createArray(isOnlyChild, parentNode, value) {
	  var node = document.createDocumentFragment();
	  renderArrayToParent(node, value, value.length);
	  node.xvdomContext = isOnlyChild ? parentNode : node.appendChild(createEmptyTextNode());
	  return node;
	};

	var createDynamic = function createDynamic(isOnlyChild, parentNode, value) {
	  switch (value && value.constructor) {
	    case String:
	    case Number:
	    case 0:
	      return createTextNode(value);

	    case Object:
	      return internalRenderNoRecycle(value);

	    case Array:
	      return createArray(isOnlyChild, parentNode, value);

	    default:
	      return createEmptyTextNode();
	  }
	};

	var componentRerender = function componentRerender(component, api) {
	  var instance = internalRerender(api._instance, component(api));
	  api._instance = instance;
	  instance.$n.xvdom = api._parentInst;
	};

	var componentSend = function componentSend(component, api, actionFn, context) {
	  // TODO: process.ENV === 'development', console.error(`Action not found #{action}`);
	  if (!actionFn) return;

	  var newState = actionFn(api, context);
	  if (newState !== api.state) {
	    api.state = newState;
	    componentRerender(component, api);
	  }
	};

	var createStatefulComponent = function createStatefulComponent(component, props, instance, rerenderFuncProp, componentInstanceProp, actions) {
	  var boundActions = new Hash();

	  var api = {
	    _onProps: actions.onProps,
	    _parentInst: instance,

	    props: props,
	    bindSend: function bindSend(action) {
	      return boundActions[action] || (boundActions[action] = function (context) {
	        componentSend(component, api, actions[action], context);
	      });
	    }
	  };

	  //TODO: process.ENV === 'development', console.error(`Stateful components require atleast an 'onInit' function to provide the initial state (see)`);
	  api.state = actions.onInit(api);

	  instance[rerenderFuncProp] = rerenderStatefulComponent;
	  instance[componentInstanceProp] = api;
	  return internalRenderNoRecycle(api._instance = component(api));
	};

	var createNoStateComponent = exports.createNoStateComponent = function createNoStateComponent(component, props) {
	  return xrender(component(props));
	};

	var internalRenderNoRecycle = function internalRenderNoRecycle(instance) {
	  var node = instance.$s.c(instance);
	  instance.$n = node;
	  node.xvdom = instance;
	  return node;
	};

	var internalRender = function internalRender(instance) {
	  var spec = instance.$s;
	  var recycledInstance = spec.r.pop(instance.key);
	  if (recycledInstance) {
	    spec.u(instance, recycledInstance);
	    return recycledInstance;
	  } else {
	    internalRenderNoRecycle(instance);
	    return instance;
	  }
	};

	var render = exports.render = function render(instance) {
	  return internalRender(instance).$n;
	};

	var internalRerender = function internalRerender(prevInstance, instance) {
	  if (internalRerenderInstance(instance, prevInstance)) return prevInstance;

	  instance = internalRender(instance);
	  replaceNode(prevInstance.$n, instance.$n);
	  recycle(prevInstance);
	  return instance;
	};

	var rerender = exports.rerender = function rerender(node, instance) {
	  return internalRerender(node.xvdom, instance).$n;
	};

	var unmount = exports.unmount = function unmount(node) {
	  unmountInstance(node.xvdom, node.parentNode);
	};

	var appendChild = function appendChild(node, child) {
	  return node.appendChild(child);
	};

	var createNode = function createNode(parentNode, bytecode, i) {
	  return appendChild(parentNode, document.createElement(REF_TO_TAG[bytecode[i]]));
	};

	var assignProps = function assignProps(node, bytecode, i, statics, dynamics) {
	  var keyid = void 0;
	  var source = void 0;
	  var numStaticProps = bytecode[i++];
	  var j = bytecode[i++];
	  while (j) {
	    source = --j < numStaticProps ? statics : dynamics;
	    keyid = bytecode[i++];
	    node[source[keyid]] = source[keyid + 1];
	  }
	  return i;
	};

	var _createComponent = function _createComponent(parentNode, component, props) {
	  var actions = component.actions;
	  var createFn = actions ? createStatefulComponent : createNoStateComponent;
	  appendChild(parentNode, createFn(component, props, actions));
	};

	var createComponentWithProps = function createComponentWithProps(parentNode, bytecode, i, statics, dynamics) {
	  var props = {};
	  var component = statics[bytecode[i++]];
	  var newi = assignProps(props, bytecode, i, statics, dynamics);
	  _createComponent(parentNode, component, props);
	  return newi;
	};

	var createComponent = function createComponent(parentNode, bytecode, i, statics, dynamics) {
	  _createComponent(parentNode, statics[bytecode[i]], {});
	};

	function RootNode() {
	  this.root = null;
	}
	RootNode.prototype.appendChild = function (node) {
	  return this.root = node;
	};

	function xrender(_ref) {
	  var _ref$t = _ref.t;
	  var bytecode = _ref$t.b;
	  var statics = _ref$t.s;
	  var dynamics = _ref.d;

	  var i = 0;
	  var lastNode = void 0,
	      curNode = void 0;
	  var rootNode = curNode = new RootNode();
	  while (i < bytecode.length) {
	    switch (bytecode[i++]) {
	      case 0:
	        // el
	        lastNode = createNode(curNode, bytecode, i++);
	        break;

	      case 1:
	        // el w/props
	        i = assignProps(lastNode = createNode(curNode, bytecode, i++), bytecode, i, statics, dynamics);
	        break;

	      case 2:
	        // component
	        createComponent(curNode, bytecode, i++, statics);
	        break;

	      case 3:
	        // component w/props
	        i = createComponentWithProps(curNode, bytecode, i++, statics, dynamics);
	        break;

	      case 4:
	        // dynamic
	        appendChild(curNode, createDynamic(true, curNode, dynamics[bytecode[i++]]));
	        break;

	      case 5:
	        // static
	        appendChild(curNode, createDynamic(true, curNode, statics[bytecode[i++]]));
	        break;

	      case 6:
	        // COMMAND: next is child (push)
	        curNode = lastNode;
	        break;

	      case 7:
	        // COMMAND: parent (pop)
	        curNode = curNode.parentNode;
	        break;
	    };
	  }

	  return rootNode.root;
	}

	exports.default = {
	  createDynamic: createDynamic,
	  el: function el(tag) {
	    return document.createElement(tag);
	  },
	  render: render,
	  rerender: rerender,
	  xrender: xrender,
	  unmount: unmount,
	  updateDynamic: updateDynamic,
	  Pool: Pool,
	  DEADPOOL: DEADPOOL
	};

	// Internal API

	var _ = exports._ = {
	  rerenderText: rerenderText,
	  rerenderInstance: rerenderInstance,
	  rerenderDynamic: rerenderDynamic,
	  rerenderArray: rerenderArrayMaybe
	};

/***/ }
/******/ ]);